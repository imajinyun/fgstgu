#include <stdio.h>

int main(int argc, char *argv[]) {
  /**
   * -> 正整数的原码、反码、补码完全一样，即符号位固定为 0，数值位相同；
   * -> 负整数的符号位固定为 1，由原码变为补码时，规则如下：
   *    a. 原码符号位 1 不变，整数的每一位二进制数位求反，得到反码；
   *    b. 反码符号位 1 不变，反码数值位最低位加 1，得到补码；
   *
   * 将二进制转为十进制，必须使用二进制的原码。
   *
   * 0b00000010 <- 原码
   * 0b00000010 <- 补码（原码在内存中的补码存储形式）
   * 0b11111101 <- 取反（取反后内存中的补码存储形式）
   * 0b10000011 <- 原码（内存中的补码转原码，负数的补码转为原码是对补码（除符号位）逐位取反后，并在最低位＋1）
   * -3
   */
  unsigned char v1 = 0b00000010;
  printf("按位取反（二进制反码）：v1 = %d\n", ~v1);

  /**
   * 0b10010011 <- 二进制数
   * 0b00111101 <- 二进制数
   * 0b00010001 <- 按位与
   * 16 + 1 = 17
   */
  unsigned char v2 = (0b10010011) & (0b00111101);
  printf("按位与：v2 = %d\n", v2);

  /**
   * 0b10010011 <- 二进制数
   * 0b00111101 <- 二进制数
   * 0b10111111 <- 按位或
   * 128 + 32 + 16 + 8 + 4 + 2 + 1 = 191
   */
  unsigned char v3 = (0b10010011) | (0b00111101); // 0b10111111 -> 191
  printf("按位或：v3 = %d\n", v3);

  /**
   * 0b10010011 <- 二进制数
   * 0b00111101 <- 二进制数
   * 0b10101110 <- 按位异或
   * 128 + 32 + 8 + 4 + 2 = 174
   */
  unsigned char v4 = (0b10010011) ^ (0b00111101); // 0b10101110 -> 174
  printf("按位异或：v4 = %d\n", v4);

  /**
   * 0b00001111 <- 二进制数
   * 0b10110110 <- 二进制数
   * 0b10111111 <- 按位或
   * 128 + 32 + 16 + 8 + 4 + 2 + 1 = 191
   */
  unsigned char opener = (0b00001111) | (0b10110110); // 10111111 -> 191
  printf("打开位（设置位）：setter = %d\n", opener);

  /**
   * 0b00111101 <- 二进制数
   * 0b01001001 <- ~0b10110110 <- 二进制数
   * 0b00001001 <- 按拉与
   * 8 + 1 = 9
   */
  unsigned char closer = (0b00111101) & (~0b10110110);
  printf("关闭位（清空位）：closer = %d\n", closer);

  /**
   * 0b10010011 <- 二进制数
   * 0b00111101 <- 二进制数
   * 0b10101110 <- 按位异或
   * 0b00111101 <- 二进制数
   * 0b10010011 <- 按位异或
   * 128 + 16 + 2 + 1 = 147
   */
  unsigned char switcher = (0b10010011) ^ (0b00111101);
  switcher ^= (0b00111101);
  printf("切换位：switcher = %d\n", switcher);
  return 0;
}
